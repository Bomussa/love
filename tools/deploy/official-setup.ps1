param(
  [string]$TunnelName = 'mms-tunnel',
  [string]$Domain = 'mmc-mms.com',
  [int]$Port = 3000,
  [int]$LoginTimeoutSec = 300
)

# Generated by Copilot
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

function Ensure-Dir($p) { if (-not (Test-Path $p)) { New-Item -ItemType Directory -Path $p | Out-Null } }

function Find-Cloudflared {
  $local = Join-Path $PSScriptRoot 'cloudflared.exe'
  $tools = Join-Path $PSScriptRoot '..\\..\\deploy\\cloudflared\\cloudflared.exe'
  foreach ($p in @($local,$tools)) { if (Test-Path $p) { return (Resolve-Path $p).Path } }
  $cmd = Get-Command cloudflared -ErrorAction SilentlyContinue
  if ($cmd) { return $cmd.Source }
  return $null
}

function Download-Cloudflared($dest) {
  Ensure-Dir (Split-Path -Parent $dest)
  $url = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe'
  Write-Host "[official] Downloading cloudflared from $url ..."
  Invoke-WebRequest -Uri $url -OutFile $dest -UseBasicParsing
  Write-Host "[official] Saved cloudflared to $dest"
}

$logsDir = Join-Path $PSScriptRoot '..\\..\\logs' | Resolve-Path | Select-Object -ExpandProperty Path
Ensure-Dir $logsDir
$publicUrlFile = Join-Path $logsDir 'public_url.txt'

$userHome = $env:USERPROFILE
$cfDir = Join-Path $userHome '.cloudflared'
Ensure-Dir $cfDir
$certPath = Join-Path $cfDir 'cert.pem'

$cf = Find-Cloudflared
if (-not $cf) {
  $preferred = Join-Path $PSScriptRoot 'cloudflared.exe'
  Download-Cloudflared -dest $preferred
  $cf = $preferred
}

if (-not (Test-Path $certPath)) {
  Write-Host '[official] cloudflared login required â€” opening browser...'
  Start-Process -FilePath $cf -ArgumentList 'login' -WindowStyle Hidden | Out-Null
  $deadline = (Get-Date).AddSeconds($LoginTimeoutSec)
  while ((Get-Date) -lt $deadline) {
    Start-Sleep -Seconds 2
    if (Test-Path $certPath) { break }
  }
  if (-not (Test-Path $certPath)) { throw "cloudflared login did not complete within $LoginTimeoutSec seconds." }
}

Write-Host "[official] Creating named tunnel '$TunnelName' (idempotent)"
try { & $cf tunnel create $TunnelName } catch { Write-Host '[official] Tunnel may already exist.' }

Write-Host "[official] Routing DNS: $Domain -> $TunnelName (idempotent)"
try { & $cf tunnel route dns $TunnelName $Domain } catch { Write-Host '[official] DNS may already be routed.' }
try { & $cf tunnel route dns $TunnelName ("www."+$Domain) } catch { Write-Host '[official] DNS www may already be routed.' }
try { & $cf tunnel route dns $TunnelName ("app."+$Domain) } catch { Write-Host '[official] DNS app may already be routed.' }

$cred = Join-Path $cfDir ("$TunnelName.json")
$cfgPath = Join-Path $cfDir 'config.yml'
$cfg = @(
  "tunnel: $TunnelName",
  "credentials-file: $cred",
  "ingress:",
  "  - hostname: app.$Domain",
  "    service: http://localhost:$Port",
  "  - hostname: www.$Domain",
  "    service: http://localhost:$Port",
  "  - hostname: $Domain",
  "    service: http://localhost:$Port",
  "  - service: http_status:404"
) -join "`n"
Set-Content -Path $cfgPath -Value $cfg -Encoding UTF8
Write-Host "[official] Wrote config: $cfgPath"

Write-Host '[official] Installing cloudflared service (requires elevation)'
$serviceInstalled = $true
try { & $cf service install | Out-Null } catch { $serviceInstalled = $false; Write-Host '[official] Service install failed or not elevated; will fallback to scheduled task.' }

if ($serviceInstalled) {
  try { Start-Service cloudflared -ErrorAction Stop } catch { Write-Host '[official] Service already running or needs elevation.' }
} else {
  # Fallback: schedule a task to run the named tunnel at logon
  $setup = Join-Path $PSScriptRoot 'setup-scheduled-task.ps1'
  powershell -NoProfile -ExecutionPolicy Bypass -File $setup -UseOfficialRun -TunnelName $TunnelName -CloudflaredPath $cf | Out-Null
  # Also start the tunnel now in background for current session
  Start-Process -FilePath $cf -ArgumentList @('tunnel','run',$TunnelName) -WindowStyle Hidden | Out-Null
}

"https://$Domain" | Out-File -FilePath $publicUrlFile -Encoding utf8 -Force
Write-Host "[official] Public URL: https://$Domain"
